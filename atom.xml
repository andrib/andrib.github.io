<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[AB]]></title>
  <link href="http://nrcpts.github.io/atom.xml" rel="self"/>
  <link href="http://nrcpts.github.io/"/>
  <updated>2014-07-16T17:22:44+07:00</updated>
  <id>http://nrcpts.github.io/</id>
  <author>
    <name><![CDATA[Andri Burman]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[QuickCount - Kertas Paku Kotak]]></title>
    <link href="http://nrcpts.github.io/blog/2014/07/16/ricuh-quick-count/"/>
    <updated>2014-07-16T16:14:10+07:00</updated>
    <id>http://nrcpts.github.io/blog/2014/07/16/ricuh-quick-count</id>
    <content type="html"><![CDATA[<p>2014 Juli 09 selesai sudah momen coblos coblosan pilpres, yang sebelumnya sudah sama-sama melakukan kampanye dengan semangat memperebutkan kursi nomor 1 dan 2 di Indonesia, ya kursi Presiden dan wakilnya. Dengan lancar KPU berhasil menyelenggarakan proses pemilihan seperti saat-saat sebelumnya, proses pemungutan suara di masing-masing TPS dipantau langsung oleh tim KPU dan para LSM bersama beberapa pihak publik lain yang sengaja hadir untuk melakukan pengambilan data (perkiraan) perhitungan yang digunakan sebagai data quick count yang saat ini diberitakan secara sporadis melalui media (terutama televisi), ricuh mewarnai proses perhitungan suara, tuding sana sini antar simpatisan dan tim sukses terjadi karena data quick count yang belum bisa dipastikan kebenarannya (memang bukan real count, hanya sampling) seharusnya tidak perlu terjadi karena sebenarnya secara resmi (berdasarkan UU), perhitungan suara pemilu hanya dilakukan oleh KPU dan akan resmi diumumkan hasilnya pada tanggal 22 Juli 2014.</p>

<p>KPU sebagai lembaga yang bertanggung jawab menyelenggarakan proses pemilihan suara setiap kali diadakan pemilu di Indonesia, sampai saat ini masih menggunakan cara konvensional (kertas + paku + kotak) yang dinilai masih cara efektif yang bisa dilakukan hingga saat ini, namun sayangnya metode konvensional seperti itu masih juga memiliki celah kecurangan dalam prosesnya, ditambahlagi kecepatan dalam mendistribusikan hasil suara di tiap daerah untuk dihitung secara terpusat membutuhkan effort yang luar biasa.</p>

<p>Pernahkah terpikir oleh KPU untuk melirik metode lain (selain kertas paku kotak) seperti dengan menggunakan bantuan teknologi misalnya, dengan teknologi KPU bisa membuat sistem pemilihan suara yang elbih efektif dan terukur baik dari sisi reliabilitas kemampuan hitung maupun keamanan data. Takut dicurangi dari sisi teknologi? hacker, cracker, script kiddies? Saya yakin sekaliber para pengkaji teknologi informasi di pemerintahan sudah sangat hebat dalam hal ini, jadi kenapa harus takut?</p>

<p>Dalam bayangan saya, dengan terintegrasinya data e-ktp yang selama ini sudah ada (entah benar atau tidak), bisa dibuatkan terminal TPS dengan peralatan multitouch screen berikut rfid ektp reader. Hanya ada 2 pihak yang terlibat dalam sistem ini, yaitu KPU dan penyelenggara e-ktp. Jaringan yang digunakan menggunakan enkripsi ssl 2048bit melalui vpn dari KPU/ektp ke masing-masing TPS, satu ektp id hanya bisa melakukan 1 kali otentikasi ke database ektp untuk mendapatkan token, dengan token unik tersebut maka pemilih dapat melakukan pilihan suara (yang diupdate ke data KPU) tanpa diketahui siapa identitasnya, pengukuran keberhasilannya adalah data jumlah otentikasi ektp harus match dengan jumlah suara yang tersimpan di KPU.</p>

<p><img class="center" src="http://nrcpts.github.io/images/img/coblos.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pemuda Indonesia Calon Negarawan Atau Politikus]]></title>
    <link href="http://nrcpts.github.io/blog/2014/07/07/pemuda-indonesia-calon-negarawan-atau-politikus/"/>
    <updated>2014-07-07T16:28:10+07:00</updated>
    <id>http://nrcpts.github.io/blog/2014/07/07/pemuda-indonesia-calon-negarawan-atau-politikus</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://nrcpts.github.io/images/img/merahputih.png" width="200" height="100">
Hiruk pikuk pesta demokrasi Indonesia saat ini terasa lebih ramai dibandingkan periode-periode sebelumnya. Dengan pesatnya perkembangan dunia teknologi di Indonesia saat ini khususnya media sosial, membuat proses kampanye pilpres 2014 terasa lebih heboh, meriah, lucu, dan kadang menjengkelkan, ditambah lagi 2 calon presiden yang akan dipilih saat ini masing-masing mempunyai masa pendukung yang sama kuat dan fanatik. Tidak jarang kita temui di media jejaring sosial, anak-anak muda Indonesia saling berbagi informasi tentang para calon yang sedang berkampanye dalam pilpres kali ini, mereka berbagi informasi dari berbagai sumber yang didapat, tidak peduli apa yang dibagikannya itu adalah fakta atau hanya karangan saja, selain itu tentang motivasi mereka pun bermacam-macam, ada yang memang benar pendukung dari salah satu capres, ada yang hanya sekedar ikut meramaikan pilpres kali ini, ada juga yang memang benar-benar mengamati proses pilpres kali ini sebagai sebuah momen demokrasi bangsa untuk dipelajari sudah sejauh mana bangsa kita mengalami perubahan sejak reformasi.</p>

<p>Bebasnya media komunikasi sosial berbasis internet di Indonesia dalam proses demokrasi kali ini juga tidak jarang dituduh sebagai biang masalah bagi beberapa pihak, berita-berita bukan fakta bahkan dikategoriakan fitnah dianggap sebagai &ldquo;black campaign&rdquo; bagi beberapa pihak, yang justru memalukan adalah seringnya ditemui penyebaran ulang berita-berita karangan tersebut diantara jerjaring pertemanan di media sosial para anak muda Indonesia, tanpa mengetahui maksud dan tujuan mengapa mereka menyebarkan berita/informasi tersebut.. ya, itulah hype dunia jejaring sosial Indonesia, tidak sedikit dari sekian banyak pengguna layanan jejaring sosial tersebut yang sepertinya terlalu kenyang akan fitur teknologi tanpa tahu hal mendasar dari apa kebutuhan mereka tentang informasi yang diterima/disebarkan.</p>

<p>Indonesia dengan pemudanya seharusnya sudah bisa merasa bangga dengan kebebasan saling bertukar informasi menggunakan teknologi internet yang dikenal lebih netral, sekarang kita bisa bicara bebas, menulis dengan bebas, tanpa paksaan dan tekanan kita bisa ikut merasakan apa yang sebenarnya terjadi dalam momen demokrasi sebuah bangsa, bangsa kita, Indonesia. Dengan semua hal tersebut, tanpa disadari kita sebagai pemuda yang ikut dalam momen demokrasi ini telah belajar menjadi bangsa yang lebih pintar, peduli, dan bangga dengan demokrasi di Indonesia, terlepas dari bagaimana masing-masing mencerna pengalaman dan pengetahuan tersebut, semoga hal yang diterima menjadi manfaat yang baik bagi bangsa kita kedepan, gunakanlah kebebasan infomasi saat ini menjadi alat terbaik untuk usaha memajukan bangsa, bukan sebaliknya.</p>

<p>Pesan dari seorang kawan, mantan pemuda seperti saya dan kalian, yang telah mengalami banyak momen demokarsi bangsa kita, telah merasakan baik dan buruknya proses tersebut.. &ldquo;Jadilah negarawan, bukan politikus.. dengan mengerti politik tanpa bijaksana dan berpandangan baik, itu hanya memperburuk kondisi bangsa kita&rdquo;. Seorang pemuda bisa saja senang akan proses dari pesta demokrasi, belajar banyak hal tentang politik, namun tanpa didasari sikap bijaksana, pandangan baik terhadap bangsa, kecintaan yang sebenarnya terhadap bangsa sendiri, maka tidak menutup kemungkinan baginya saat menjadi kuat/besar nanti akan menggunakan politik hanya unutk keinginannya sebagai individu..Sebaliknya dengan ilmu yang kalian dapat tersebut, jadilah negarawan, ahli menjalankan negara, memimpin dengan politik secara taat menyusun kebijakan negara dengan suatu pandangan ke depan, serta mampu mengelola masalah bangsa kita dengan kebijaksanaan dan kewibawaan.</p>

<p>Harapan untuk hasil dari momen demokrasi 2014 Indonesia:</p>

<p>Siapapun presidennya, semoga mulai diterapkan pemilihan posisi menteri strategis non partai, seperti pertanian, komunikasi informasi, kelautan, dan lain-lain, menteri strategis non partai bisa diambil dari profesional yang benar-benar mampu menjalankan kewajibannya sesuai bidang yang dikuasai.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Layanan SMTP Relay Berbayar]]></title>
    <link href="http://nrcpts.github.io/blog/2014/04/10/layanan-smtp-relay-berbayar/"/>
    <updated>2014-04-10T13:10:10+07:00</updated>
    <id>http://nrcpts.github.io/blog/2014/04/10/layanan-smtp-relay-berbayar</id>
    <content type="html"><![CDATA[<p>Komunikasi email sebuah aplikasi memegang peranan yang sangat penting dan tidak dapat diabaikan begitu saja tentang reliabilitasnya, khususnya pada aplikasi layanan publik yang  dibuat untuk digunakan oleh pengguna umum secara global.</p>

<p>Sebagai contoh, pada sebuah aplikasi web, pada fungsi registrasi pengguna membutuhkan email sebagai alat untuk validasi akun pengguna, sebagai media notifikasi bagi pengguna, atau juga digunakan sebagai <em>mailing list</em> dalam aplikasi, tetapi apa yang terjadi jika semua email yang dikirim tidak terlihat dalam <em>inbox</em> para recipients? Tentunya bukan merupakan alasan yang baik dalam membentuk layanan dari aplikasi, jika kita pernah mengatakan kalimat &ldquo;<em>coba cek spam box anda..</em>&rdquo; kepada <em>recipients</em> dari aplikasi kita :)</p>

<p>Dalam lingkup sistem administrasi baik server-server berbasis linux atau lainnya, biasanya memiliki kendala pada sistem MTA (<em>Mail Transfer Agent</em>) pada mail server, seperti blacklist ip, whitelist ip, spam scores, spam complaints, atau konfigurasi server mail yang buruk, yang menyebabkan setiap email yang terkirim dari mail server tersebut dianggap SPAM oleh banyak mail server global, terutama penyedia layanan besar seperti yahoo dam google.</p>

<p>Banyak hal/persayaratan sebuah mail server yang kita buat dapat memiliki reputasi sending yang baik dalam skala global, dan hal tersebut membutuhkan waktu lama, khususnya dalam reputasi domain sender, domain-domain baru yang kita gunakan bisa saja akan tetap dianggap SPAM walaupun sudah memiliki mail server yang terkonfigurasi dengan baik.</p>

<p>Solusi sementara yang efektif bagi bisnis adalah dengan tetap menjalankan komunikasi email dari aplikasi dengan menggunakan layanan <em>smtp relay</em> berbayar, dengan cara ini aplikasi yang mengirimkan email melalui MTA harus melakukan metode relay ke MTA milik layanan smtp relay berbayar yang digunakan, dengan cara tersebut email yang terkirim melalui aplikasi memiliki garansi terkirim dengan baik ke seluruh tujuan recipients.</p>

<p>Berikut ini adalah beberapa layanan smtp relay berbayar yang dapat digunakan:</p>

<ul>
<li><a href="http://postmarkapp.com/">Postmark</a></li>
<li><a href="http://aws.amazon.com/ses/">Amazon SES</a></li>
<li><a href="http://sendgrid.com/">Sendgrid</a></li>
<li><a href="http://socketlabs.com/">SocketLabs</a></li>
<li><a href="http://www.mailjet.com/">MailJet</a></li>
<li><a href="http://www.elasticemail.com/">Elastic Mail</a></li>
<li><a href="http://www.elasticemail.com/">smtp2go</a></li>
</ul>


<p>Dari beberapa layanan diatas yang pernah saya coba, hanya postmark dan smtp2go, postmark adalah layanan kedua setelah saya gagal pada smtp2go :)</p>

<p>Kedua layanan sebenarnya ini cukup baik, smtp2go sangat mudah dalam proses instalasi, hanya saja smtp2go memiliki peraturan yang terlalu <em>strict</em> dalam masalah spam complaints dan reputasi akun kita (berhubungan dengan pola kirim email aplikasi), yang akhirnya jadi menyebalkan :)</p>

<br />


<p><img class="center" src="http://nrcpts.github.io/images/img/postmark.png"></p>

<p><a href="http://postmarkapp.com/">Postmark</a> memiliki kelebihan lain dalam masalah perhitungan sewa layanan, yaitu menggunakan <em>credits</em> untuk mengirim email, jika kita memiliki 1000 credit, maka mail server kita bisa menggunakan relay sebanyak 1000 email terkirim. Pricing credits yang diberikan juga cukup murah, saat ini $7.5 per 1000 credit. Metode pricing menggunakan <em>credits</em> ini dinilai cocok bagi startup yang sebenarnya belum membutuhkan terlalu banyak komunikasi email pada tahap awal, tentunya tidak cocok jika menggunakan layanan smtp relay yang memiliki <em>bulk sending quota</em> dalam waktu yang ditentukan baik <em>annually</em> atau <em>monthly</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mengenal Teknologi RAID Storage]]></title>
    <link href="http://nrcpts.github.io/blog/2014/04/08/mengenal-teknologi-raid-storage/"/>
    <updated>2014-04-08T12:14:10+07:00</updated>
    <id>http://nrcpts.github.io/blog/2014/04/08/mengenal-teknologi-raid-storage</id>
    <content type="html"><![CDATA[<p><strong>RAID</strong> sebuah akronim lama yang pertama kali didefinisikan oleh David A. Petterson, Garth A. Gibson dan Randy Katz di Berkeley pada tahun 1987 untuk “<strong>Redundant Array Of Inexpensive Disks</strong>”, awalnya istilah ini  diartikan untuk sebuah teknologi media penyimpanan data yang memberikan pengguna komputer mendapatkan performa terbaik dari komponen hard drive yang tergolong low-cost pada personal computer, dan ketangguhan sebuah sistem media penyimpanan data yang dapat dipercaya dengan menggunakan teknik penyusunan beberapa set hard-drive menjadi sebuah array untuk beberapa tujuan yang salah satunya adalah mengenai redundancy data.
Namun saat ini, seiring berkembangnya industri hardware dan semakin majunya teknologi komputer, RAID sering didefinisikan sebagai “<strong>Redundant Array of Independent Disks</strong>” memiliki definisi yang sama dengan istilah RAID sebelumnya, tetapi sudah tidak lagi menyandang istilah low-cost pada implementasinya.</p>

<p>RAID dikategorikan menjadi beberapa model atau skema, setiap masing-masing skema RAID tersebut memiliki tujuan yang berbeda. Perbedaan beberapa skema RAID tersebut diberi nama dengan format kata RAID di depannya dengan diikuti kode angka, seperti RAID 0, RAID 1, dan lainnya. Beberapa tujuan penting dari skema-skema RAID diantaranya adalah, proteksi terhadap kehilangan data, kapasitas, dan kecepatan. Keperluan mendasar untuk membuat sebuah sistem RAID ada 2 yaitu, RAID controller baik berupa hardware atau software, dan kebutuhan satunya lagi sudah pasti jumlah minimal untuk membentuk sebuah disk array adalah 2 dan akan bertambah tergantung dari fungsi skema yang akan digunakan.</p>

<p>Ilustrasi perintah tulis dari cpu ke hdd:</p>

<p><img class="center" src="http://www.fujitsu.com/img/STRSYS/system/09-glossary-raid-raid5+0.gif"></p>

<p>Secara umum, RAID dikategorikan menjadi dua kategori dasar yaitu, “<em>standard levels</em>” dan “<em>nested levels</em>”, standard-levels RAID hanya memiliki 1 kode angka dibelakang istilah RAID dengan maksud 1 kode angka skema tersebut adalah mewakili fungsi dasar dari skema RAID yang dimaksud, sedangkan nested-levels atau sering disebut “<em>non-standard levels</em>” adalah teknik penggabungan fungsi dasar dari skema standard RAID, contohnya RAID 1+0 atau sering ditulis menjadi RAID 10, adalah penggabungan dari skema dasar RAID 1 dan RAID 0.</p>

<p><strong>Beberapa Skema Standard-Levels RAID</strong></p>

<ol>
<li><p><strong>RAID 0</strong>
Sering disebut “striped set without parity”, bertujuan memperbaiki performa disk dan perluasan media penyimpanan tetapi tanpa memiliki fitur toleransi kesalahan pada sistem baca/tulis terhadap kelompok hard-drive tersebut. Lebih sering dimanfaatkan sebagai penambah performa sistem media penyimpanan, semakin banyak disk pada array RAID 0 maka akan semakin besar bandwidth yang diperlukan untuk proses baca/tulis. RAID 0 tidak memiliki error-checking, jadi jika terdapat error pada proses baca/tulis sudah pasti kesalahan tersbut tidak dapat diperbaiki, lebih buruknya jika salah satu dari disk didalam array rusak, maka keseluruhan array tersebut ikut menjadi rusak.</p></li>
<li><p><strong>RAID 1</strong>
Sering disebut “mirrored set without parity”, bertujuan memberikan kontrol penuh terhadap kemungkinan kesalahan pada sistem media penyimpanan yang terdiri dari array 2 atau lebih hard-drive. Dengan mode ini otomatis akan terjadi penurunan performa kecepatan proses tulis karena  sistem akan menggunakan resource I/O ganda untuk melakukan satu kali penulisan, khusus untuk beberapa model sistem operasi yang memiliki fitur “multi-threaded” yang mendukung “split-seeks”  tidak akan terjadi penurunan performa kecepatan proses baca, bahkan sebaliknya skema RAID ini akan menambahkan performa dalam proses tersebut.</p></li>
<li><p><strong>RAID 2</strong>
Sering disebut “striping with parity”, menggunakan metode ECC (error-correcting-code) versi “hamming code”.  Bertujuan untuk mendapatkan efek “striping” dengan “on the fly” koreksi kesalahan. RAID 2 di implementasi dengan teknik dengan melakukan “split” terhadap data pada level “bit”, dan menyebarkannya kedalam beberapa jumlah disk pada array. RAID 2 jarang digunakan karena termasuk konfigurasi yang cukup mahal, membutuhkan hardware RAID controller dan hard-drive yang special.</p></li>
<li><p><strong>RAID 3</strong>
Sering disebut “Striped set with dedicated parity”, menggunakan salah satu disk dalam array sebagai “dedicated-parity”, metode strip pada array terjadi pada level byte, kerusakan/kegagalan proses pada array dapat dikendalikan oleh “dedicated-parity” disk ini dengan baik tanpa menurunkan performa array. Kemungkinan akan terjadi “bottleneck” terhadap dedicated-parity disk tersebut, karena disk tersebut harus diakses kapanpun setiap kali array di akses.</p></li>
<li><p><strong>RAID 4</strong>
Sering disebut “block level parity”, identik dengan RAID 3 tetapi menggunakan metode block-level striping, dengan menggunakan metode striping ini terbukti meningkatkan performa “random access performance” pada array dibandingkan dengan RAID 3, namun pada RAID ini juga tetap menggunakan “dedicated-parity” sebagai error-control nya dimana dedicated-parity juga mengalami penurunan performa khususnya pada “random access performance”.</p></li>
<li><p><strong>RAID 5</strong>
Sering disebut “Striped set with distributed parity”, sama dengan RAID 4 yaitu block-level striping namun pada skema ini error-control pada array menggunakan metode “distributed-parity”, dimana data dan informasi parity disimpan didalam semua disk pada array, ini terbukti mengurangi bottleneck yang terjadi pada metode “dedicated-parity” yang tergantung pada single-unit disk yang berperan sebagai parity disk dari array. Satu drive failure pada array harus segera digantikan dan bangun ulang kondisi array, pada kondisi ini array tidak rusak keseluran hanya akan terjadi penurunan performa pada array, tetapi jika drive failure kedua terjadi pada skema ini maka array akan rusak seluruhnya dan pasti menyebabkan data loss.</p></li>
<li><p><strong>RAID 6</strong>
Sering disebut “Striped set with dual distributed parity”, memberikan fitur toleransi kesalahan lebih baik dari RAID 5 dimana array akan tetap berjalan walaupun 2 disk drive pada array telah rusak, salah satu kelebihan dalam error-control pada skema ini adalah sistem mendapatkan toleransi waktu yang lebih untuk membangun ulang array yang rusak, walaupun salah satu dari dua disk drive pengganti tetap gagal dalam melakukan perbaikan ketika array sedang dibangun kembali.</p></li>
</ol>


<p>Untuk “nested-levels” RAID sebenarnya yang terjadi hanyalah konfigurasi dengan cara penggabungan skema “standard-levels” RAID untuk berbagai tujuan tertentu dalam sistem media penyimpanan. Beberapa metode penggabungan tersebut diantaranya adalah RAID 0+1, RAID 1+0, RAID 5+0 dan RAID 5+1.</p>

<p>Referensi:</p>

<ul>
<li><a href="http://www.pcguide.com/ref/hdd/perf/raid">http://www.pcguide.com/ref/hdd/perf/raid</a></li>
<li><a href="http://en.wikipedia.org/wiki/Redundant_array_of_independent_disks">http://en.wikipedia.org/wiki/Redundant_array_of_independent_disks</a></li>
<li><a href="http://en.wikipedia.org/wiki/Nested_RAID_levels">http://en.wikipedia.org/wiki/Nested_RAID_levels</a></li>
<li><a href="http://en.wikipedia.org/wiki/Hamming_code">http://en.wikipedia.org/wiki/Hamming_code</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ghost - Platform Blog Berbasis Nodejs]]></title>
    <link href="http://nrcpts.github.io/blog/2014/04/06/ghost-platform-blog-berbasis-nodejs/"/>
    <updated>2014-04-06T13:30:50+07:00</updated>
    <id>http://nrcpts.github.io/blog/2014/04/06/ghost-platform-blog-berbasis-nodejs</id>
    <content type="html"><![CDATA[<p><a href="http://ghost.org/">Ghost</a> merupakan platform blog sederhana dan cepat berbasis node.js, dibuat khusus sebagai <em>blog publishing engine</em>, dirancang dengan baik dan terstruktur serta memiliki kendali kustomisasi penuh bagi developer untuk mengubah isi konten, mengubah tampilan dengan mudah (membuat <em>template</em> desain sendiri) atau bahkan membuat modul program node.js tersendiri, <a href="http://ghost.org/">Ghost</a> dibuat sepenuhnya terbuka (<em>Open Source</em> ).</p>

<p align='center'>
<img class="left" src="http://nrcpts.github.io/images/img/ghost.png" width="350" height="350" title="image" alt="images">
</p>


<p>Seperti <em>blog publishing engine</em> pada umumnya, <a href="http://ghost.org/">Ghost</a> memiliki alur penggunaan aplikasi web yang sama, hanya saja sedikit berbeda pada modul <em>content management system</em> atau sering disebut sebagai <em>dashboard</em> pada <em>engine blog</em>, yaitu menggunakan <em>markdown</em> sebagai fungsi edit post, yang memudahkan web developer untuk tidak tergantung kepada wysiwyg editor berbasis javascript yang konvensional seperti ckeditor dan lainnya.</p>

<p><a href="http://ghost.org/">Ghost</a> &ldquo;berjalan&rdquo; di atas framwork node.js sepenuhnya, memiliki berbagai <em>driver</em> database untuk digunakan seperti postgre dan mysql yang tergolong <em>relational database</em>, selain itu Ghost juga mendukung penggunaan <strong>NoSQL</strong> database seperti MongoDB dan lainnya. Bagi para developer web yang terbiasa menggunakan <strong>LAMP Stack</strong>, mungkin sudah saatnya mulai mencoba beralih stack yang berbeda seperti node.js dalam membuat sebuah website, sebagian orang menganggap node.js ini masih baru dan belum bisa dikategorikan sebagai framework web development dalam skala <em>enterprise</em>, tetapi perlu dipertimbangkan bahwa node.js ini membuat proses development lebih cepat dan menghasilkan aplikasi web yang <em>scalable</em> :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[First Post With Jekyll]]></title>
    <link href="http://nrcpts.github.io/blog/2014/04/01/first-post-with-jekyll/"/>
    <updated>2014-04-01T13:14:10+07:00</updated>
    <id>http://nrcpts.github.io/blog/2014/04/01/first-post-with-jekyll</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
</feed>
